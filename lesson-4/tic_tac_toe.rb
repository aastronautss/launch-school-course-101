MAX_WINS = 5

# Standard output
def prompt(input)
  puts "=> #{input}"
end

# Returns a fresh board
def set_board
  [[" ", " ", " "],
   [" ", " ", " "],
   [" ", " ", " "]]
end

# Prints the board
def display_board(board)
  system 'clear'
  puts '  1   2   3'
  horiz_seprator = '  --+---+--'
  board.each_with_index do |row, row_index|
    puts "#{row_index + 1} #{row[0]} | #{row[1]} | #{row[2]}"
    puts horiz_seprator unless row_index >= board.length - 1
  end
end

# Returns an array of coordinates for each empty space in the board.
# Each coordinate is in the form of an array [x, y].
def empty_spaces(board)
  empties = []
  board.each_with_index do |row, row_index|
    row.each_with_index do |col, col_index|
      empties << [row_index, col_index] if col == ' '
    end
  end
  empties
end

# Returns the board's columns.
def get_cols(board)
  cols = Array.new(board[0].size) { Array.new }
  board.each do |row|
    row.each_with_index do |cell, col_index|
      cols[col_index] << cell
    end
  end

  cols
end

# Returns the board's rows.
def get_rows(board)
  board
end

# Returns the board's diagonals.
def get_diags(board)
  diags = Array.new(2) { Array.new }

  0.upto(2)   { |index| diags[0] << board[index][index] }
  diags[1] << board[0][2]
  diags[1] << board[1][1]
  diags[1] << board[2][0]

  diags
end

def winning_positions(board)
  get_rows(board) + get_cols(board) + get_diags(board)
end

# -----------------------
# Board Status
# -----------------------

# Returns true if the board is full.
def full_board?(board)
  empty_spaces(board).empty?
end

# Returns true if the passed space is empty on the passed board.
def space_empty?(coords, board)
  empty_spaces(board).include? coords
end

# Inserts the given piece at the given coordinates on the given board.
def play_move(board, coords, piece)
  x, y = coords
  board[x][y] = piece
  board
end

# -----------------------
# User input
# -----------------------

# Takes a valid input.
# Returns an array containing the user's sele
def parse_input(raw_input)
  raw_input.gsub!(/(\?|\s)/, '')
  coords = raw_input.split ''
  coords.map! { |number| number.to_i - 1 }
  coords
end

# Validates the user's input, making sure it's in the right format.
def valid_input?(raw_input)
  !!raw_input.match(/^\d,?\s?\d$/)
end

# -----------------------
# Moves
# -----------------------

# Prompts the user's move, validates it, and places the piece on the board.
def user_move(board)
  prompt 'Pick your coordinates (row, column): '
  prompt 'Format: 2, 3 or 1 3 or 21'

  coords = []
  loop do
    input = gets.chomp
    if valid_input? input
      coords = parse_input input
      break if space_empty?(coords, board)
      prompt "Space not available!"
    else
      prompt "Invalid input!"
    end
  end

  play_move(board, coords, 'X')
end

# The computer makes a random move on the board.
def computer_move(board)
  move = empty_spaces(board).sample
  play_move(board, move, "O")
end

# -----------------------
# Win Conditions
# -----------------------

# Returns the "X" or "O" depending on who won, "T" if it's a tie, or nil if
# nobody has won.
def get_winner(board)
  positions_to_check = winning_positions(board)
  full_rows = positions_to_check.select do |position|
    position.all? { |piece| piece == "X" } ||
      position.all? { |piece| piece == "O" }
  end

  return full_rows[0][0] unless full_rows.empty?
  return "T" if full_board? board

  nil
end

# Takes the result (typically generated by the get_winner method) and score
# hash, and prints a useful message.
def display_score(result, scores)
  case result
  when "X"
    prompt "Player wins! This round!"
  when "O"
    prompt "Computer wins!"
  when "T"
    prompt "It's a tie!"
  end
  prompt "Player: #{scores["X"]}"
  prompt "Computer: #{scores["O"]}"
end

# Increments the winner's score.
def update_scores(result, scores)
  scores[result] += 1
end

# Returns true if any score has reached the target.
def game_over?(scores)
  scores.values.any? { |score| score == MAX_WINS }
end

# Prints a winner message. Assumes a winner exists.
def display_winner(scores)
  winner = ''
  if scores['X'] == MAX_WINS
    winner = 'Player'
  else
    winner = 'Computer'
  end

  prompt "#{winner} wins!"
end

# Returns true if the user wants to play again (via a prompt) and false
# otherwise.
def user_play_again?
  prompt "Would you like to play again? (y to play again)"
  response = gets.chomp
  response.casecmp('y') == 0
end

# -----------------------
# Main execution loop
# -----------------------

loop do
  scores = { "X" => 0, "O" => 0 }
  loop do
    board = set_board
    result = nil

    loop do
      display_board(board)

      board = user_move(board)
      result = get_winner(board)
      break if result

      board = computer_move(board)
      result = get_winner(board)
      break if result
    end

    update_scores(result, scores)

    display_board(board)
    display_score(result, scores)
    break if game_over?(scores)
  end

  display_winner(scores)

  break unless user_play_again?
end
